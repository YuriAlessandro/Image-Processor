{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
effects.h\par \pard\plain 
{\tc\tcl2 \v bib/effects.h}
{\xe \v bib/effects.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     1 \par
   10 void ef_thresholding(Pixel image[lat][lat], int value)\{\par
   11     int i, j, gray;\par
   12 \par
   13     /* O laço percorre a matriz de pixels.*/\par
   14     for(i = 0; i < height; i++)\par
   15         for(j = 0; j < width; j++)\{\par
   16             /* A variável gray recebe a média dos valores do Pixel*/\par
   17             gray = (image[i][j].red + image[i][j].green + image[i][j].blue)/3;\par
   18 \par
   19             /* Se gray for maior que o valor inserido, o Pixel fica branco. Ao contrário, o Pixel fica preto.*/\par
   20             if(gray > value)\{\par
   21                 image[i][j].red = 1;\par
   22                 image[i][j].green = 1;\par
   23                 image[i][j].blue = 1;\par
   24             \}else\{\par
   25                 image[i][j].red = 0;\par
   26                 image[i][j].green = 0;\par
   27                 image[i][j].blue = 0;\par
   28             \}\par
   29         \}\par
   30     clrRange = 1;\par
   31 \par
   32     /* A matriz de pixels é mandada para a função que a escreverá num arquivo.*/\par
   33     create_new_file(image);\par
   34 \}\par
   35 \par
   40 void ef_blur(Pixel image[lat][lat])\{\par
   41     int i, j;\par
   42     \par
   43     /* "Pixel temp" é uma matriz temporária que irão receber a nova imagem, borrada. */\par
   44     Pixel temp[lat][lat];\par
   45     \par
   46     /* O laço percorre a matriz de pixels.*/\par
   47     for(i = 1; i < lat-1; i++)\par
   48         for(j = 1; j < lat-1; j++)\{\par
   49                 /* A matriz temporária soma os pixel ao imediatamente redor do atual pixel do laço e tira a sua média.*/\par
   50                 temp[i][j].red = (\par
   51                     image[i-1][j-1].red + image[i-1][j].red + image[i-1][j+1].red +\par
   52                     image[i][j-1].red + image[i][j].red + image[i][j+1].red +\par
   53                     image[i+1][j-1].red + image[i+1][j].red + image[i+1][j+1].red)/9;\par
   54 \par
   55                 temp[i][j].green = (\par
   56                     image[i-1][j-1].green + image[i-1][j].green + image[i-1][j+1].green +\par
   57                     image[i][j-1].green + image[i][j].green + image[i][j+1].green +\par
   58                     image[i+1][j-1].green + image[i+1][j].green + image[i+1][j+1].green)/9;\par
   59 \par
   60                 temp[i][j].blue = (\par
   61                     image[i-1][j-1].blue + image[i-1][j].blue + image[i-1][j+1].blue +\par
   62                     image[i][j-1].blue + image[i][j].blue + image[i][j+1].blue +\par
   63                     image[i+1][j-1].blue + image[i+1][j].blue + image[i+1][j+1].blue)/9;\par
   64 \par
   65         \}\par
   66     /* O segundo laço transporta todos os novos valores da matriz temporária novamente para a matriz "image".*/\par
   67     for(i = 1; i < lat-1; i++)\par
   68         for(j = 1; j < lat-1; j++)\par
   69             image[i][j] = temp[i][j];\par
   70     \par
   71     /* A matriz de pixels é mandada para a função que a escreverá num arquivo.*/\par
   72     create_new_file(image);\par
   73 \}\par
   74 \par
   79 void ef_sharpening(Pixel image[lat][lat])\{\par
   80     int i, j;\par
   81     \par
   82     /* Pixel temp é uma matriz temporária, que será usada para receber a imagem com as alterações*/\par
   83     Pixel temp[lat][lat];\par
   84     \par
   85     /* O laço percorre a matriz de pixels.*/\par
   86     for(i = 1; i < lat-1; i++)\par
   87         for(j = 1; j < lat-1; j++)\{\par
   88                 /* O pixel "central" é multiplicado por 5, enquanto os pixel imediatamente ao lado e em cima são\par
   89                  * multiplicados por -1 e somados ao pixel central.*/\par
   90                 temp[i][j].red = (image[i][j].red*5 - image[i-1][j].red - image[i][j-1].red - image[i][j+1].red - \par
   91                     image[i+1][j].red);\par
   92                 \par
   93                 temp[i][j].green = (image[i][j].green*5 - image[i-1][j].green - image[i][j-1].green - image[i][j+1].green - \par
   94                     image[i+1][j].green);\par
   95                 \par
   96                 temp[i][j].blue = (image[i][j].blue*5 - image[i-1][j].blue - image[i][j-1].blue - image[i][j+1].blue - \par
   97                     image[i+1][j].blue);\par
   98                 \par
   99                 /* Os operadores ternários verificam se os novos valores são maiores que 255 ou menores que 0.\par
  100                  * Caso seja maior que 255, o valor novo será o próprio 255.\par
  101                  * Caso seja menor que 0, o valor será o pŕoprio 0.\par
  102                  * Isso evita que os valores dos pixels saiam do color range e quebrem a imagem */\par
  103                 temp[i][j].red = (temp[i][j].red < 255) ? temp[i][j].red : 255; \par
  104                 temp[i][j].red = (temp[i][j].red > 0) ? temp[i][j].red : 0;\par
  105                 temp[i][j].green = (temp[i][j].green < 255) ? temp[i][j].green : 255; \par
  106                 temp[i][j].green = (temp[i][j].green > 0) ? temp[i][j].green : 0;\par
  107                 temp[i][j].blue = (temp[i][j].blue < 255) ? temp[i][j].blue : 255; \par
  108                 temp[i][j].blue = (temp[i][j].blue > 0) ? temp[i][j].blue : 0;\par
  109                 \par
  110     \}\par
  111     /* O segundo laço transporta todos os novos valores da matriz temporária novamente para a matriz "image".*/\par
  112     for(i = 1; i < lat-1; i++)\par
  113         for(j = 1; j < lat-1; j++)\par
  114             image[i][j] = temp[i][j];\par
  115 \par
  116     /* A matriz de pixels é mandada para a função que a escreverá num arquivo.*/\par
  117     create_new_file(image);\par
  118 \par
  119 \}\par
  120 \par
  125 void ef_rotate_left(Pixel image[lat][lat])\{\par
  126     int i, j;\par
  127     \par
  128     /* Matriz auxiliar temporária.*/ \par
  129     Pixel temp[lat][lat]; \par
  130 \par
  131     /* A matriz original é copiada para a matriz temporária.*/\par
  132     for(i = 0; i < height; i++)\{\par
  133         for(j = 0; j < width; j++)\{\par
  134             temp[i][j] = image[i][j];\par
  135         \}\par
  136     \}\par
  137     \par
  138     /* Os pixels passam a ser copiados em ordem e postos de baixo pra cima, da esquerda pra direita,\par
  139      * na matriz original.*/\par
  140     for (i = 0; i < height; i++)\par
  141             for (j = 0; j < width; j++)\par
  142                 image[width-j-1][i] = temp[i][j];\par
  143 \par
  144     /* Os valores de altura e largura são trocados.*/\par
  145     i = height;\par
  146     height = width;\par
  147     width = i;\par
  148 \par
  149     /* A matriz de pixels é mandada para a função que a escreverá num arquivo.*/\par
  150     create_new_file(image);\par
  151 \}\par
  152 \par
  157 void ef_enlarge(Pixel image[lat][lat], int value)\{\par
  158     int i, j, k, l;\par
  159     \par
  160     /* Um novo arquivo é criado e as informações básicas da imagem são escritos nele.*/\par
  161     FILE *newfile;\par
  162     newfile = fopen(name, "w");\par
  163     fprintf(newfile, "%s\\n%i %i\\n%i\\n", filetype, width*value, height*value, clrRange);\par
  164     \par
  165     /* Os laços percorrem a matriz e escrevem no arquivo os pixels o número de vezes necessária\par
  166      * para aumentar o tamanho total da imagem pelo valor inserido.*/\par
  167     for(i = 0; i < height; i++)\par
  168         for (k = 0; k < value; k++)\par
  169             for(j = 0; j < width; j++)\par
  170                 for(l = 0; l < value; l++)\par
  171                     fprintf(newfile, "%i %i %i ", image[i][j].red, image[i][j].green, image[i][j].blue);\par
  172 \par
  173     /* A conexão com o arquivo é encerrada e uma mensagem final é impressa na tela.*/\par
  174     fclose(newfile);\par
  175     system("clear");\par
  176     printf("O arquivo %s foi criado com sucesso na pasta raíz do programa.\\n", name);\par
  177 \}\par
  178 \par
  183 void ef_reduce(Pixel image[lat][lat], int value)\{\par
  184     int i, j, k, l, lat2 = lat/value;\par
  185     Pixel temp[lat2][lat2]; /* Matriz temporária auxiliar.*/\par
  186     \par
  187     /* Os valores da matriz auxiliar são zerados.*/\par
  188     for(i = 0; i < lat2; i++)\par
  189         for(j = 0; j < lat2; j++)\{\par
  190             temp[i][j].red = 0;\par
  191             temp[i][j].green = 0;\par
  192             temp[i][j].blue = 0;\par
  193         \}\par
  194 \par
  195     /* Os laços percorrem a matriz e atribuem a cada espaço da matriz auxiliar a soma dos valores contidos\par
  196      * num quadrado de altura e largura do tamanho do valor inserido na função. Em seguida é tirado a média\par
  197      * aritmética desses valores contidos na matriz temporária.*/\par
  198     for(i = 0; i < height; i += value)\{\par
  199         for(j = 0; j < width; j += value)\{\par
  200             for (k = 0; k < value; k++)\{\par
  201                 for(l = 0; l < value; l++)\{\par
  202                     temp[i/value][j/value].red += image[i+k][j+l].red;\par
  203                     temp[i/value][j/value].green += image[i+k][j+l].green;\par
  204                     temp[i/value][j/value].blue += image[i+k][j+l].blue;\par
  205                 \}\par
  206             \}\par
  207             temp[i/value][j/value].red /= value*value;\par
  208             temp[i/value][j/value].green /= value*value;\par
  209             temp[i/value][j/value].blue /= value*value;\par
  210         \}\par
  211     \}\par
  212 \par
  213     /* Os parâmetros de altura e largura da imagem são divididos pelo valor inserido na função.*/\par
  214     width /= value;\par
  215     height /= value;\par
  216     lat /= value;\par
  217     \par
  218     /* A matriz de pixels é mandada para a função que a escreverá num arquivo.*/    \par
  219     create_new_file(temp);\par
  220 \}\par
  221 \par
  226 void ef_black_white(Pixel image[lat][lat])\{\par
  227     int i, j, gray;\par
  228     \par
  229     /* O laço percorre pela matriz de pixels*/\par
  230     for(i = 0; i < height; i++)\par
  231         for(j = 0; j < width; j++)\{\par
  232             /*"gray" soma os valores RGB e tira a média deles*/\par
  233             gray = (image[i][j].red + image[i][j].green + image[i][j].blue)/3;  \par
  234             /* Os três valores RGB recebem "gray", tornando a imagem cinza*/\par
  235             image[i][j].red = gray;\par
  236             image[i][j].green = gray;\par
  237             image[i][j].blue = gray;\par
  238         \}\par
  239 \par
  240     /* A matriz de pixels é mandada para a função que a escreverá num arquivo.*/\par
  241     create_new_file(image);\par
  242 \}\par
  243 \par
  248 void ef_horizontal_mirror(Pixel image[lat][lat])\{\par
  249     int i, j;   \par
  250     \par
  251     /*Pixel temp é uma matriz temporária, que será usada para receber a imagem espelhada*/\par
  252     Pixel temp[lat][lat]; \par
  253     \par
  254     /* O laço percorre a matriz de pixels.*/\par
  255     for(i = 0; i < height; i++)\{\par
  256         for(j = 0; j < width; j++)\{\par
  257             /* A matriz temp recebe os valores da matriz image, que estão em ordem, da direita pra esquerda.*/\par
  258             temp[i][width-j-1].red = image[i][j].red;\par
  259             temp[i][width-j-1].green = image[i][j].green;\par
  260             temp[i][width-j-1].blue = image[i][j].blue;\par
  261         \}\par
  262     \}\par
  263     \par
  264     /* A matriz de pixels é mandada para a função que a escreverá num arquivo.*/\par
  265     create_new_file(temp);\par
  266 \}\par
  267 \par
  272 void ef_border_detection(Pixel image[lat][lat])\{\par
  273     int i, j;\par
  274     \par
  275     /*Pixel temp é uma matriz temporária.*/\par
  276     Pixel temp[lat][lat]; \par
  277     \par
  278     /* Chama a matriz que zera todos os valores da matriz temporária.*/\par
  279     null_matrix(temp); \par
  280     \par
  281     /* O laço percorre a matriz de pixels*/\par
  282     for(i = 1; i < lat-1; i++)\par
  283         for(j = 1; j < lat-1; j++)\{\par
  284                 /* O pixel central é multiplicado por 8 e os imediatamente ao seu lado por -1. \par
  285                  * Ao final, o atual pixel da matriz temporária será a soma do pixel central e \par
  286                  * dos imadiatamente ao seu lado (incluindo diagonais).*/\par
  287                 temp[i][j].red =\par
  288                     (image[i][j].red*8) - image[i-1][j-1].red - image[i-1][j].red -\par
  289                     image[i-1][j+1].red - image[i][j-1].red - image[i][j+1].red -\par
  290                     image[i+1][j-1].red - image[i+1][j].red - image[i+1][j+1].red;\par
  291 \par
  292                 temp[i][j].green =\par
  293                     (image[i][j].green*8) - image[i-1][j-1].green - image[i-1][j].green -\par
  294                     image[i-1][j+1].green - image[i][j-1].green - image[i][j+1].green -\par
  295                     image[i+1][j-1].green - image[i+1][j].green - image[i+1][j+1].green;\par
  296 \par
  297                 temp[i][j].blue =\par
  298                     (image[i][j].blue*8) - image[i-1][j-1].blue - image[i-1][j].blue -\par
  299                     image[i-1][j+1].blue - image[i][j-1].blue - image[i][j+1].blue -\par
  300                     image[i+1][j-1].blue - image[i+1][j].blue - image[i+1][j+1].blue;\par
  301                 \par
  302                 /* Os operadores ternários verificam se os novos valores são maiores que 255 ou menores que 0.\par
  303                  * Caso seja maior que 255, o valor novo será o próprio 255.\par
  304                  * Caso seja menor que 0, o valor será o pŕoprio 0.\par
  305                  * Isso evita que os valores dos pixels saiam do color ranger e quebrem a imagem. */\par
  306                 \par
  307                 temp[i][j].red = (temp[i][j].red < 0) ? 0 : temp[i][j].red;\par
  308                 temp[i][j].red = (temp[i][j].red > 255) ? 255 : temp[i][j].red;\par
  309                 temp[i][j].green = (temp[i][j].green < 0) ? 0 : temp[i][j].green;\par
  310                 temp[i][j].green = (temp[i][j].green > 255) ? 255 : temp[i][j].green;\par
  311                 temp[i][j].blue = (temp[i][j].blue < 0) ? 0 : temp[i][j].blue;\par
  312                 temp[i][j].blue = (temp[i][j].blue > 255) ? 255 : temp[i][j].blue;\par
  313         \}\par
  314     \par
  315 \par
  316     /* A função thresholding é chamada para binarizar a imagem e aumentar a visibidade das bordas.*/\par
  317     ef_thresholding(temp, 127);\par
  318 \}\par
  319 \par
  324 void ef_negative(Pixel image[lat][lat], int clrRange)\{\par
  325     int i, j;\par
  326     \par
  327     /* O laço percorre a matriz de pixels.*/\par
  328     for(i = 0; i < height; i++)\{\par
  329         for(j = 0; j < width; j++)\{\par
  330             /* Retira o atual valor do pixel do color range.*/\par
  331             image[i][j].red = clrRange - image[i][j].red;\par
  332             image[i][j].green = clrRange - image[i][j].green;\par
  333             image[i][j].blue = clrRange - image[i][j].blue; \par
  334         \}\par
  335     \}\par
  336 \par
  337     /* A matriz de pixels é mandada para a função que a escreverá num arquivo.*/\par
  338     create_new_file(image);\par
  339 \}\par
  340 \par
  345 void ef_sepia(Pixel image[lat][lat])\{\par
  346     int i, j;\par
  347     \par
  348     /* O laço percorre a matriz de pixels.*/\par
  349     for(i = 0; i < height; i++)\{\par
  350         for(j = 0; j < width; j++)\{\par
  351             image[i][j].red = (image[i][j].red * 0.493) + (image[i][j].green * 0.469) + (image[i][j].blue * 0.089);\par
  352             \par
  353             image[i][j].green = (image[i][j].red * 0.349) + (image[i][j].green * 0.486) + (image[i][j].blue * 0.168);\par
  354             \par
  355             image[i][j].blue = (image[i][j].red * 0.272) + (image[i][j].green * 0.334) + (image[i][j].blue * 0.131);\par
  356             \par
  357             /* Os valores são pré determinados, por meio de testes, para deixar a imagem com tons de marrom/amarelo.*/\par
  358 \par
  359         \}\par
  360     \}\par
  361     /* A matriz de pixels é mandada para a função que a escreverá num arquivo.*/\par
  362     create_new_file(image);\par
  363 \}\par
}
}